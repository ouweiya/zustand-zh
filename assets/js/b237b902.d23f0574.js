"use strict";(self.webpackChunkzustand_zh=self.webpackChunkzustand_zh||[]).push([[196],{7688:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>i,contentTitle:()=>a,default:()=>l,frontMatter:()=>s,metadata:()=>c,toc:()=>u});var r=e(4848),o=e(8453);const s={title:"Comparison",description:"How Zustand stacks up against similar libraries",nav:1},a=void 0,c={id:"getting-started/comparison",title:"Comparison",description:"How Zustand stacks up against similar libraries",source:"@site/docs/getting-started/comparison.md",sourceDirName:"getting-started",slug:"/getting-started/comparison",permalink:"/zustand-zh/docs/getting-started/comparison",draft:!1,unlisted:!1,editUrl:"https://github.com/ouweiya/zustand-zh/docs/getting-started/comparison.md",tags:[],version:"current",frontMatter:{title:"Comparison",description:"How Zustand stacks up against similar libraries",nav:1},sidebar:"tutorialSidebar",next:{title:"Introduction",permalink:"/zustand-zh/docs/getting-started/introduction"}},i={},u=[{value:"Redux",id:"redux",level:2},{value:"State Model (vs Redux)",id:"state-model-vs-redux",level:3},{value:"Render Optimization (vs Redux)",id:"render-optimization-vs-redux",level:3},{value:"Valtio",id:"valtio",level:2},{value:"State Model (vs Valtio)",id:"state-model-vs-valtio",level:3},{value:"Render Optimization (vs Valtio)",id:"render-optimization-vs-valtio",level:3},{value:"Jotai",id:"jotai",level:2},{value:"State Model (vs Jotai)",id:"state-model-vs-jotai",level:3},{value:"Render Optimization (vs Jotai)",id:"render-optimization-vs-jotai",level:3},{value:"Recoil",id:"recoil",level:2},{value:"State Model (vs Recoil)",id:"state-model-vs-recoil",level:3},{value:"Render Optimization (vs Recoil)",id:"render-optimization-vs-recoil",level:3},{value:"Npm Downloads Trend",id:"npm-downloads-trend",level:2}];function d(n){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"Zustand is one of many state management libraries for React.\r\nOn this page we will discuss Zustand\r\nin comparison to some of these libraries,\r\nincluding Redux, Valtio, Jotai, and Recoil."}),"\n",(0,r.jsx)(t.p,{children:"Each library has its own strengths and weaknesses,\r\nand we will compare key differences and similarities between each."}),"\n",(0,r.jsx)(t.h2,{id:"redux",children:"Redux"}),"\n",(0,r.jsx)(t.h3,{id:"state-model-vs-redux",children:"State Model (vs Redux)"}),"\n",(0,r.jsx)(t.p,{children:"Conceptually, Zustand and Redux are quite similar,\r\nboth are based on an immutable state model.\r\nHowever, Redux requires your app to be wrapped\r\nin context providers; Zustand does not."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Zustand"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { create } from 'zustand'\r\n\r\ntype State = {\r\n  count: number\r\n}\r\n\r\ntype Actions = {\r\n  increment: (qty: number) => void\r\n  decrement: (qty: number) => void\r\n}\r\n\r\nconst useCountStore = create<State & Actions>((set) => ({\r\n  count: 0,\r\n  increment: (qty: number) => set((state) => ({ count: state.count + qty })),\r\n  decrement: (qty: number) => set((state) => ({ count: state.count - qty })),\r\n}))\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { create } from 'zustand'\r\n\r\ntype State = {\r\n  count: number\r\n}\r\n\r\ntype Actions = {\r\n  increment: (qty: number) => void\r\n  decrement: (qty: number) => void\r\n}\r\n\r\ntype Action = {\r\n  type: keyof Actions\r\n  qty: number\r\n}\r\n\r\nconst countReducer = (state: State, action: Action) => {\r\n  switch (action.type) {\r\n    case 'increment':\r\n      return { count: state.count + action.qty }\r\n    case 'decrement':\r\n      return { count: state.count - action.qty }\r\n    default:\r\n      return state\r\n  }\r\n}\r\n\r\nconst useCountStore = create<State & Actions>((set) => ({\r\n  count: 0,\r\n  dispatch: (action: Action) => set((state) => countReducer(state, action)),\r\n}))\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Redux"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { createStore } from 'redux'\r\nimport { useSelector, useDispatch } from 'react-redux'\r\n\r\ntype State = {\r\n  count: number\r\n}\r\n\r\ntype Action = {\r\n  type: 'increment' | 'decrement'\r\n  qty: number\r\n}\r\n\r\nconst countReducer = (state: State, action: Action) => {\r\n  switch (action.type) {\r\n    case 'increment':\r\n      return { count: state.count + action.qty }\r\n    case 'decrement':\r\n      return { count: state.count - action.qty }\r\n    default:\r\n      return state\r\n  }\r\n}\r\n\r\nconst countStore = createStore(countReducer)\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { createSlice, configureStore } from '@reduxjs/toolkit'\r\n\r\nconst countSlice = createSlice({\r\n  name: 'count',\r\n  initialState: { value: 0 },\r\n  reducers: {\r\n    incremented: (state, qty: number) => {\r\n      // Redux Toolkit does not mutate the state, it uses the Immer library\r\n      // behind scenes, allowing us to have something called \"draft state\".\r\n      state.value += qty\r\n    },\r\n    decremented: (state, qty: number) => {\r\n      state.value -= qty\r\n    },\r\n  },\r\n})\r\n\r\nconst countStore = configureStore({ reducer: countSlice.reducer })\n"})}),"\n",(0,r.jsx)(t.h3,{id:"render-optimization-vs-redux",children:"Render Optimization (vs Redux)"}),"\n",(0,r.jsx)(t.p,{children:"When it comes to render optimizations within your app,\r\nthere are no major differences in approach between Zustand and Redux.\r\nIn both libraries it is recommended\r\nthat you manually apply render optimizations by using selectors."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Zustand"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { create } from 'zustand'\r\n\r\ntype State = {\r\n  count: number\r\n}\r\n\r\ntype Actions = {\r\n  increment: (qty: number) => void\r\n  decrement: (qty: number) => void\r\n}\r\n\r\nconst useCountStore = create<State & Actions>((set) => ({\r\n  count: 0,\r\n  increment: (qty: number) => set((state) => ({ count: state.count + qty })),\r\n  decrement: (qty: number) => set((state) => ({ count: state.count - qty })),\r\n}))\r\n\r\nconst Component = () => {\r\n  const count = useCountStore((state) => state.count)\r\n  const increment = useCountStore((state) => state.increment)\r\n  const decrement = useCountStore((state) => state.decrement)\r\n  // ...\r\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Redux"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { createStore } from 'redux'\r\nimport { useSelector, useDispatch } from 'react-redux'\r\n\r\ntype State = {\r\n  count: number\r\n}\r\n\r\ntype Action = {\r\n  type: 'increment' | 'decrement'\r\n  qty: number\r\n}\r\n\r\nconst countReducer = (state: State, action: Action) => {\r\n  switch (action.type) {\r\n    case 'increment':\r\n      return { count: state.count + action.qty }\r\n    case 'decrement':\r\n      return { count: state.count - action.qty }\r\n    default:\r\n      return state\r\n  }\r\n}\r\n\r\nconst countStore = createStore(countReducer)\r\n\r\nconst Component = () => {\r\n  const count = useSelector((state) => state.count)\r\n  const dispatch = useDispatch()\r\n  // ...\r\n}\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { useSelector } from 'react-redux'\r\nimport type { TypedUseSelectorHook } from 'react-redux'\r\nimport { createSlice, configureStore } from '@reduxjs/toolkit'\r\n\r\nconst countSlice = createSlice({\r\n  name: 'count',\r\n  initialState: { value: 0 },\r\n  reducers: {\r\n    incremented: (state, qty: number) => {\r\n      // Redux Toolkit does not mutate the state, it uses the Immer library\r\n      // behind scenes, allowing us to have something called \"draft state\".\r\n      state.value += qty\r\n    },\r\n    decremented: (state, qty: number) => {\r\n      state.value -= qty\r\n    },\r\n  },\r\n})\r\n\r\nconst countStore = configureStore({ reducer: countSlice.reducer })\r\n\r\nconst useAppSelector: TypedUseSelectorHook<typeof countStore.getState> =\r\n  useSelector\r\n\r\nconst useAppDispatch: () => typeof countStore.dispatch = useDispatch\r\n\r\nconst Component = () => {\r\n  const count = useAppSelector((state) => state.count.value)\r\n  const dispatch = useAppDispatch()\r\n  // ...\r\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"valtio",children:"Valtio"}),"\n",(0,r.jsx)(t.h3,{id:"state-model-vs-valtio",children:"State Model (vs Valtio)"}),"\n",(0,r.jsxs)(t.p,{children:["Zustand and Valtio approach state management\r\nin a fundamentally different way.\r\nZustand is based on the ",(0,r.jsx)(t.strong,{children:"immutable"})," state model,\r\nwhile Valtio is based on the ",(0,r.jsx)(t.strong,{children:"mutable"})," state model."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Zustand"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { create } from 'zustand'\r\n\r\ntype State = {\r\n  obj: { count: number }\r\n}\r\n\r\nconst store = create<State>(() => ({ obj: { count: 0 } }))\r\n\r\nstore.setState((prev) => ({ obj: { count: prev.obj.count + 1 } }))\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Valtio"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { proxy } from 'valtio'\r\n\r\nconst state = proxy({ obj: { count: 0 } })\r\n\r\nstate.obj.count += 1\n"})}),"\n",(0,r.jsx)(t.h3,{id:"render-optimization-vs-valtio",children:"Render Optimization (vs Valtio)"}),"\n",(0,r.jsx)(t.p,{children:"The other difference between Zustand and Valtio\r\nis Valtio makes render optimizations through property access.\r\nHowever, with Zustand, it is recommended that\r\nyou manually apply render optimizations by using selectors."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Zustand"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { create } from 'zustand'\r\n\r\ntype State = {\r\n  count: number\r\n}\r\n\r\nconst useCountStore = create<State>(() => ({\r\n  count: 0,\r\n}))\r\n\r\nconst Component = () => {\r\n  const count = useCountStore((state) => state.count)\r\n  // ...\r\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Valtio"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { proxy, useSnapshot } from 'valtio'\r\n\r\nconst state = proxy({\r\n  count: 0,\r\n})\r\n\r\nconst Component = () => {\r\n  const { count } = useSnapshot(state)\r\n  // ...\r\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"jotai",children:"Jotai"}),"\n",(0,r.jsx)(t.h3,{id:"state-model-vs-jotai",children:"State Model (vs Jotai)"}),"\n",(0,r.jsx)(t.p,{children:"There are two major differences between Zustand and Jotai.\r\nFirstly, Zustand is a single store,\r\nwhile Jotai consists of primitive atoms\r\nthat can be composed together.\r\nSecondly, a Zustand store is an external store,\r\nmaking it more suitable when access outside of React is required."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Zustand"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { create } from 'zustand'\r\n\r\ntype State = {\r\n  count: number\r\n}\r\n\r\ntype Actions = {\r\n  updateCount: (\r\n    countCallback: (count: State['count']) => State['count'],\r\n  ) => void\r\n}\r\n\r\nconst useCountStore = create<State & Actions>((set) => ({\r\n  count: 0,\r\n  updateCount: (countCallback) =>\r\n    set((state) => ({ count: countCallback(state.count) })),\r\n}))\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Jotai"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { atom } from 'jotai'\r\n\r\nconst countAtom = atom<number>(0)\n"})}),"\n",(0,r.jsx)(t.h3,{id:"render-optimization-vs-jotai",children:"Render Optimization (vs Jotai)"}),"\n",(0,r.jsx)(t.p,{children:"Jotai achieves render optimizations through atom dependency.\r\nHowever, with Zustand it is recommended that\r\nyou manually apply render optimizations by using selectors."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Zustand"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { create } from 'zustand'\r\n\r\ntype State = {\r\n  count: number\r\n}\r\n\r\ntype Actions = {\r\n  updateCount: (\r\n    countCallback: (count: State['count']) => State['count'],\r\n  ) => void\r\n}\r\n\r\nconst useCountStore = create<State & Actions>((set) => ({\r\n  count: 0,\r\n  updateCount: (countCallback) =>\r\n    set((state) => ({ count: countCallback(state.count) })),\r\n}))\r\n\r\nconst Component = () => {\r\n  const count = useCountStore((state) => state.count)\r\n  const updateCount = useCountStore((state) => state.updateCount)\r\n  // ...\r\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Jotai"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { atom, useAtom } from 'jotai'\r\n\r\nconst countAtom = atom<number>(0)\r\n\r\nconst Component = () => {\r\n  const [count, updateCount] = useAtom(countAtom)\r\n  // ...\r\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"recoil",children:"Recoil"}),"\n",(0,r.jsx)(t.h3,{id:"state-model-vs-recoil",children:"State Model (vs Recoil)"}),"\n",(0,r.jsx)(t.p,{children:"The difference between Zustand and Recoil\r\nis similar to that between Zustand and Jotai.\r\nRecoil depends on atom string keys\r\ninstead of atom object referential identities.\r\nAdditionally, Recoil needs to wrap your app in a context provider."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Zustand"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { create } from 'zustand'\r\n\r\ntype State = {\r\n  count: number\r\n}\r\n\r\ntype Actions = {\r\n  setCount: (countCallback: (count: State['count']) => State['count']) => void\r\n}\r\n\r\nconst useCountStore = create<State & Actions>((set) => ({\r\n  count: 0,\r\n  setCount: (countCallback) =>\r\n    set((state) => ({ count: countCallback(state.count) })),\r\n}))\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Recoil"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { atom } from 'recoil'\r\n\r\nconst count = atom({\r\n  key: 'count',\r\n  default: 0,\r\n})\n"})}),"\n",(0,r.jsx)(t.h3,{id:"render-optimization-vs-recoil",children:"Render Optimization (vs Recoil)"}),"\n",(0,r.jsx)(t.p,{children:"Similar to previous optimization comparisons,\r\nRecoil makes render optimizations through atom dependency.\r\nWhereas with Zustand, it is recommended that\r\nyou manually apply render optimizations by using selectors."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Zustand"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { create } from 'zustand'\r\n\r\ntype State = {\r\n  count: number\r\n}\r\n\r\ntype Actions = {\r\n  setCount: (countCallback: (count: State['count']) => State['count']) => void\r\n}\r\n\r\nconst useCountStore = create<State & Actions>((set) => ({\r\n  count: 0,\r\n  setCount: (countCallback) =>\r\n    set((state) => ({ count: countCallback(state.count) })),\r\n}))\r\n\r\nconst Component = () => {\r\n  const count = useCountStore((state) => state.count)\r\n  const setCount = useCountStore((state) => state.setCount)\r\n  // ...\r\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Recoil"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { atom, useRecoilState } from 'recoil'\r\n\r\nconst countAtom = atom({\r\n  key: 'count',\r\n  default: 0,\r\n})\r\n\r\nconst Component = () => {\r\n  const [count, setCount] = useRecoilState(countAtom)\r\n  // ...\r\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"npm-downloads-trend",children:"Npm Downloads Trend"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://npm-compare.com/@reduxjs/toolkit,zustand,recoil,jotai,valtio/#timeRange=THREE_YEARS",children:"Npm Downloads Trend of State Management Libraries for React"})}),"\n"]})]})}function l(n={}){const{wrapper:t}={...(0,o.R)(),...n.components};return t?(0,r.jsx)(t,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},8453:(n,t,e)=>{e.d(t,{R:()=>a,x:()=>c});var r=e(6540);const o={},s=r.createContext(o);function a(n){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof n?n(t):{...t,...n}}),[t,n])}function c(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),r.createElement(s.Provider,{value:t},n.children)}}}]);