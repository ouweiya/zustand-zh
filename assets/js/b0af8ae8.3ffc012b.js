"use strict";(self.webpackChunkzustand_zh=self.webpackChunkzustand_zh||[]).push([[94],{771:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var t=r(4848),s=r(8453);const a={title:"Persisting store data",nav:17},o=void 0,i={id:"integrations/persisting-store-data",title:"Persisting store data",description:"The Persist middleware enables you to store",source:"@site/docs/integrations/persisting-store-data.md",sourceDirName:"integrations",slug:"/integrations/persisting-store-data",permalink:"/zustand-zh/docs/integrations/persisting-store-data",draft:!1,unlisted:!1,editUrl:"https://github.com/ouweiya/zustand-zh/docs/integrations/persisting-store-data.md",tags:[],version:"current",frontMatter:{title:"Persisting store data",nav:17},sidebar:"tutorialSidebar",previous:{title:"Immer middleware",permalink:"/zustand-zh/docs/integrations/immer-middleware"},next:{title:"Third-party Libraries",permalink:"/zustand-zh/docs/integrations/third-party-libraries"}},d={},c=[{value:"Simple example",id:"simple-example",level:2},{value:"Options",id:"options",level:2},{value:"<code>name</code>",id:"name",level:3},{value:"<code>storage</code>",id:"storage",level:3},{value:"<code>partialize</code>",id:"partialize",level:3},{value:"<code>onRehydrateStorage</code>",id:"onrehydratestorage",level:3},{value:"<code>version</code>",id:"version",level:3},{value:"<code>migrate</code>",id:"migrate",level:3},{value:"<code>merge</code>",id:"merge",level:3},{value:"<code>skipHydration</code>",id:"skiphydration",level:3},{value:"API",id:"api",level:2},{value:"<code>getOptions</code>",id:"getoptions",level:3},{value:"<code>setOptions</code>",id:"setoptions",level:3},{value:"<code>clearStorage</code>",id:"clearstorage",level:3},{value:"<code>rehydrate</code>",id:"rehydrate",level:3},{value:"<code>hasHydrated</code>",id:"hashydrated",level:3},{value:"<code>onHydrate</code>",id:"onhydrate",level:3},{value:"<code>onFinishHydration</code>",id:"onfinishhydration",level:3},{value:"<code>createJSONStorage</code>",id:"createjsonstorage",level:3},{value:"Hydration and asynchronous storages",id:"hydration-and-asynchronous-storages",level:2},{value:"Usage in Next.js",id:"usage-in-nextjs",level:3},{value:"FAQ",id:"faq",level:2},{value:"How can I check if my store has been hydrated",id:"how-can-i-check-if-my-store-has-been-hydrated",level:3},{value:"How can I use a custom storage engine",id:"how-can-i-use-a-custom-storage-engine",level:3},{value:"How can I rehydrate on storage event",id:"how-can-i-rehydrate-on-storage-event",level:3},{value:"How do I use it with TypeScript",id:"how-do-i-use-it-with-typescript",level:3},{value:"How do I use it with Map and Set",id:"how-do-i-use-it-with-map-and-set",level:3}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["The Persist middleware enables you to store\r\nyour Zustand state in a storage\r\n(e.g., ",(0,t.jsx)(n.code,{children:"localStorage"}),", ",(0,t.jsx)(n.code,{children:"AsyncStorage"}),", ",(0,t.jsx)(n.code,{children:"IndexedDB"}),", etc.),\r\nthus persisting its data."]}),"\n",(0,t.jsxs)(n.p,{children:["Note that this middleware supports both\r\nsynchronous storages, like ",(0,t.jsx)(n.code,{children:"localStorage"}),",\r\nand asynchronous storages, like ",(0,t.jsx)(n.code,{children:"AsyncStorage"}),",\r\nbut using an asynchronous storage does come with a cost.\r\nSee ",(0,t.jsx)(n.a,{href:"#hydration-and-asynchronous-storages",children:"Hydration and asynchronous storages"}),"\r\nfor more details."]}),"\n",(0,t.jsx)(n.h2,{id:"simple-example",children:"Simple example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { create } from 'zustand'\r\nimport { persist, createJSONStorage } from 'zustand/middleware'\r\n\r\nexport const useBearStore = create(\r\n  persist(\r\n    (set, get) => ({\r\n      bears: 0,\r\n      addABear: () => set({ bears: get().bears + 1 }),\r\n    }),\r\n    {\r\n      name: 'food-storage', // name of the item in the storage (must be unique)\r\n      storage: createJSONStorage(() => sessionStorage), // (optional) by default, 'localStorage' is used\r\n    },\r\n  ),\r\n)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"options",children:"Options"}),"\n",(0,t.jsx)(n.h3,{id:"name",children:(0,t.jsx)(n.code,{children:"name"})}),"\n",(0,t.jsx)(n.p,{children:"This is the only required option.\r\nThe given name is going to be the key\r\nused to store your Zustand state in the storage,\r\nso it must be unique."}),"\n",(0,t.jsx)(n.h3,{id:"storage",children:(0,t.jsx)(n.code,{children:"storage"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Type: ",(0,t.jsx)(n.code,{children:"() => StateStorage"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"StateStorage"})," can be imported with:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { StateStorage } from 'zustand/middleware'\n"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Default: ",(0,t.jsx)(n.code,{children:"createJSONStorage(() => localStorage)"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Enables you to use your own storage. Simply pass a function that returns the storage you want to use. It's recommended to use the ",(0,t.jsx)(n.a,{href:"#createjsonstorage",children:(0,t.jsx)(n.code,{children:"createJSONStorage"})})," helper function to create a ",(0,t.jsx)(n.code,{children:"storage"})," object that is compliant with the ",(0,t.jsx)(n.code,{children:"StateStorage"})," interface."]}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { persist, createJSONStorage } from 'zustand/middleware'\r\n\r\nexport const useBoundStore = create(\r\n  persist(\r\n    (set, get) => ({\r\n      // ...\r\n    }),\r\n    {\r\n      // ...\r\n      storage: createJSONStorage(() => AsyncStorage),\r\n    },\r\n  ),\r\n)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"partialize",children:(0,t.jsx)(n.code,{children:"partialize"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Type: ",(0,t.jsx)(n.code,{children:"(state: Object) => Object"})]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Default: ",(0,t.jsx)(n.code,{children:"(state) => state"})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Enables you to pick some of the state's fields to be stored in the storage."}),"\n",(0,t.jsx)(n.p,{children:"You could omit multiple fields using the following:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"export const useBoundStore = create(\r\n  persist(\r\n    (set, get) => ({\r\n      foo: 0,\r\n      bar: 1,\r\n    }),\r\n    {\r\n      // ...\r\n      partialize: (state) =>\r\n        Object.fromEntries(\r\n          Object.entries(state).filter(([key]) => !['foo'].includes(key)),\r\n        ),\r\n    },\r\n  ),\r\n)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Or you could allow only specific fields using the following:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"export const useBoundStore = create(\r\n  persist(\r\n    (set, get) => ({\r\n      foo: 0,\r\n      bar: 1,\r\n    }),\r\n    {\r\n      // ...\r\n      partialize: (state) => ({ foo: state.foo }),\r\n    },\r\n  ),\r\n)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onrehydratestorage",children:(0,t.jsx)(n.code,{children:"onRehydrateStorage"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Type: ",(0,t.jsx)(n.code,{children:"(state: Object) => ((state?: Object, error?: Error) => void) | void"})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This option enables you to pass a listener function\r\nthat will be called when the storage is hydrated."}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"export const useBoundStore = create(\r\n  persist(\r\n    (set, get) => ({\r\n      // ...\r\n    }),\r\n    {\r\n      // ...\r\n      onRehydrateStorage: (state) => {\r\n        console.log('hydration starts')\r\n\r\n        // optional\r\n        return (state, error) => {\r\n          if (error) {\r\n            console.log('an error happened during hydration', error)\r\n          } else {\r\n            console.log('hydration finished')\r\n          }\r\n        }\r\n      },\r\n    },\r\n  ),\r\n)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"version",children:(0,t.jsx)(n.code,{children:"version"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Type: ",(0,t.jsx)(n.code,{children:"number"})]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Default: ",(0,t.jsx)(n.code,{children:"0"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["If you want to introduce a breaking change in your storage\r\n(e.g. renaming a field), you can specify a new version number.\r\nBy default, if the version in the storage\r\ndoes not match the version in the code,\r\nthe stored value won't be used.\r\nYou can use the ",(0,t.jsx)(n.a,{href:"#migrate",children:"migrate"})," function (see below)\r\nto handle breaking changes in order to persist previously stored data."]}),"\n",(0,t.jsx)(n.h3,{id:"migrate",children:(0,t.jsx)(n.code,{children:"migrate"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Type: ",(0,t.jsx)(n.code,{children:"(persistedState: Object, version: number) => Object | Promise<Object>"})]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Default: ",(0,t.jsx)(n.code,{children:"(persistedState) => persistedState"})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"You can use this option to handle versions migration.\r\nThe migrate function takes the persisted state\r\nand the version number as arguments.\r\nIt must return a state that is compliant\r\nto the latest version (the version in the code)."}),"\n",(0,t.jsx)(n.p,{children:"For instance, if you want to rename a field, you can use the following:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"export const useBoundStore = create(\r\n  persist(\r\n    (set, get) => ({\r\n      newField: 0, // let's say this field was named otherwise in version 0\r\n    }),\r\n    {\r\n      // ...\r\n      version: 1, // a migration will be triggered if the version in the storage mismatches this one\r\n      migrate: (persistedState, version) => {\r\n        if (version === 0) {\r\n          // if the stored value is in version 0, we rename the field to the new name\r\n          persistedState.newField = persistedState.oldField\r\n          delete persistedState.oldField\r\n        }\r\n\r\n        return persistedState\r\n      },\r\n    },\r\n  ),\r\n)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"merge",children:(0,t.jsx)(n.code,{children:"merge"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Type: ",(0,t.jsx)(n.code,{children:"(persistedState: Object, currentState: Object) => Object"})]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Default: ",(0,t.jsx)(n.code,{children:"(persistedState, currentState) => ({ ...currentState, ...persistedState })"})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"In some cases, you might want to use a custom merge function\r\nto merge the persisted value with the current state."}),"\n",(0,t.jsx)(n.p,{children:"By default, the middleware does a shallow merge.\r\nThe shallow merge might not be enough\r\nif you have partially persisted nested objects.\r\nFor instance, if the storage contains the following:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"{\r\n  foo: {\r\n    bar: 0,\r\n  }\r\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"But your Zustand store contains:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"{\r\n  foo: {\r\n    bar: 0,\r\n    baz: 1,\r\n  }\r\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The shallow merge will erase the ",(0,t.jsx)(n.code,{children:"baz"})," field from the ",(0,t.jsx)(n.code,{children:"foo"})," object.\r\nOne way to fix this would be to give a custom deep merge function:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"export const useBoundStore = create(\r\n  persist(\r\n    (set, get) => ({\r\n      foo: {\r\n        bar: 0,\r\n        baz: 1,\r\n      },\r\n    }),\r\n    {\r\n      // ...\r\n      merge: (persistedState, currentState) =>\r\n        deepMerge(currentState, persistedState),\r\n    },\r\n  ),\r\n)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"skiphydration",children:(0,t.jsx)(n.code,{children:"skipHydration"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Type: ",(0,t.jsx)(n.code,{children:"boolean | undefined"})]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Default: ",(0,t.jsx)(n.code,{children:"undefined"})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"By default the store will be hydrated on initialization."}),"\n",(0,t.jsx)(n.p,{children:"In some applications you may need to control when the first hydration occurs.\r\nFor example, in server-rendered apps."}),"\n",(0,t.jsxs)(n.p,{children:["If you set ",(0,t.jsx)(n.code,{children:"skipHydration"}),", the initial call for hydration isn't called,\r\nand it is left up to you to manually call ",(0,t.jsx)(n.code,{children:"rehydrate()"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"export const useBoundStore = create(\r\n  persist(\r\n    () => ({\r\n      count: 0,\r\n      // ...\r\n    }),\r\n    {\r\n      // ...\r\n      skipHydration: true,\r\n    },\r\n  ),\r\n)\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useBoundStore } from './path-to-store';\r\n\r\nexport function StoreConsumer() {\r\n  // hydrate persisted store after on mount\r\n  useEffect(() => {\r\n    useBoundStore.persist.rehydrate();\r\n  }, [])\r\n\r\n  return (\r\n    //...\r\n  )\r\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"api",children:"API"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Version: >=3.6.3"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The Persist API enables you to do a number of interactions\r\nwith the Persist middleware\r\nfrom inside or outside of a React component."}),"\n",(0,t.jsx)(n.h3,{id:"getoptions",children:(0,t.jsx)(n.code,{children:"getOptions"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Type: ",(0,t.jsx)(n.code,{children:"() => Partial<PersistOptions>"})]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Returns: Options of the Persist middleware"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"For example, it can be used to obtain the storage name:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"useBoundStore.persist.getOptions().name\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setoptions",children:(0,t.jsx)(n.code,{children:"setOptions"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Type: ",(0,t.jsx)(n.code,{children:"(newOptions: Partial<PersistOptions>) => void"})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Changes the middleware options.\r\nNote that the new options will be merged with the current ones."}),"\n",(0,t.jsx)(n.p,{children:"For instance, this can be used to change the storage name:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"useBoundStore.persist.setOptions({\r\n  name: 'new-name',\r\n})\n"})}),"\n",(0,t.jsx)(n.p,{children:"Or even to change the storage engine:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"useBoundStore.persist.setOptions({\r\n  storage: createJSONStorage(() => sessionStorage),\r\n})\n"})}),"\n",(0,t.jsx)(n.h3,{id:"clearstorage",children:(0,t.jsx)(n.code,{children:"clearStorage"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Type: ",(0,t.jsx)(n.code,{children:"() => void"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Clears everything stored under the ",(0,t.jsx)(n.a,{href:"#name",children:"name"})," key."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"useBoundStore.persist.clearStorage()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"rehydrate",children:(0,t.jsx)(n.code,{children:"rehydrate"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Type: ",(0,t.jsx)(n.code,{children:"() => Promise<void>"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["In some cases, you might want to trigger the rehydration manually.\r\nThis can be done by calling the ",(0,t.jsx)(n.code,{children:"rehydrate"})," method."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"await useBoundStore.persist.rehydrate()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"hashydrated",children:(0,t.jsx)(n.code,{children:"hasHydrated"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Type: ",(0,t.jsx)(n.code,{children:"() => boolean"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This is a non-reactive getter to check\r\nif the storage has been hydrated\r\n(note that it updates when calling ",(0,t.jsx)(n.a,{href:"#rehydrate",children:(0,t.jsx)(n.code,{children:"rehydrate"})}),")."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"useBoundStore.persist.hasHydrated()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onhydrate",children:(0,t.jsx)(n.code,{children:"onHydrate"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Type: ",(0,t.jsx)(n.code,{children:"(listener: (state) => void) => () => void"})]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Returns: Unsubscribe function"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This listener will be called when the hydration process starts."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const unsub = useBoundStore.persist.onHydrate((state) => {\r\n  console.log('hydration starts')\r\n})\r\n\r\n// later on...\r\nunsub()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"onfinishhydration",children:(0,t.jsx)(n.code,{children:"onFinishHydration"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Type: ",(0,t.jsx)(n.code,{children:"(listener: (state) => void) => () => void"})]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Returns: Unsubscribe function"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This listener will be called when the hydration process ends."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const unsub = useBoundStore.persist.onFinishHydration((state) => {\r\n  console.log('hydration finished')\r\n})\r\n\r\n// later on...\r\nunsub()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"createjsonstorage",children:(0,t.jsx)(n.code,{children:"createJSONStorage"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Type: ",(0,t.jsx)(n.code,{children:"(getStorage: () => StateStorage, options?: JsonStorageOptions) => StateStorage"})]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Returns: ",(0,t.jsx)(n.code,{children:"PersistStorage"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This helper function enables you to create a ",(0,t.jsx)(n.a,{href:"#storage",children:(0,t.jsx)(n.code,{children:"storage"})})," object which is useful when you want to use a custom storage engine."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"getStorage"})," is a function that returns the storage engine with the properties ",(0,t.jsx)(n.code,{children:"getItem"}),", ",(0,t.jsx)(n.code,{children:"setItem"}),", and ",(0,t.jsx)(n.code,{children:"removeItem"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"options"})," is an optional object that can be used to customize the serialization and deserialization of the data. ",(0,t.jsx)(n.code,{children:"options.reviver"})," is a function that is passed to ",(0,t.jsx)(n.code,{children:"JSON.parse"})," to deserialize the data. ",(0,t.jsx)(n.code,{children:"options.replacer"})," is a function that is passed to ",(0,t.jsx)(n.code,{children:"JSON.stringify"})," to serialize the data."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { createJSONStorage } from 'zustand/middleware'\r\n\r\nconst storage = createJSONStorage(() => sessionStorage, {\r\n  reviver: (key, value) => {\r\n    if (value && value.type === 'date') {\r\n      return new Date(value)\r\n    }\r\n    return value\r\n  },\r\n  replacer: (key, value) => {\r\n    if (value instanceof Date) {\r\n      return { type: 'date', value: value.toISOString() }\r\n    }\r\n    return value\r\n  },\r\n})\n"})}),"\n",(0,t.jsx)(n.h2,{id:"hydration-and-asynchronous-storages",children:"Hydration and asynchronous storages"}),"\n",(0,t.jsx)(n.p,{children:'To explain what is the "cost" of asynchronous storages,\r\nyou need to understand what is hydration.'}),"\n",(0,t.jsx)(n.p,{children:"In a nutshell, hydration is a process\r\nof retrieving persisted state from the storage\r\nand merging it with the current state."}),"\n",(0,t.jsxs)(n.p,{children:["The Persist middleware does two kinds of hydration:\r\nsynchronous and asynchronous.\r\nIf the given storage is synchronous (e.g., ",(0,t.jsx)(n.code,{children:"localStorage"}),"),\r\nhydration will be done synchronously.\r\nOn the other hand, if the given storage is asynchronous (e.g., ",(0,t.jsx)(n.code,{children:"AsyncStorage"}),"),\r\nhydration will be done asynchronously (shocking, I know!)."]}),"\n",(0,t.jsx)(n.p,{children:"But what's the catch?\r\nWith synchronous hydration,\r\nthe Zustand store will already have been hydrated at its creation.\r\nIn contrast, with asynchronous hydration,\r\nthe Zustand store will be hydrated later on, in a microtask."}),"\n",(0,t.jsxs)(n.p,{children:["Why does it matter?\r\nAsynchronous hydration can cause some unexpected behaviors.\r\nFor instance, if you use Zustand in a React app,\r\nthe store will ",(0,t.jsx)(n.strong,{children:"not"})," be hydrated at the initial render.\r\nIn cases where your app depends on the persisted value at page load,\r\nyou might want to wait until\r\nthe store has been hydrated before showing anything.\r\nFor example, your app might think the user\r\nis not logged in because it's the default,\r\nbut in reality the store has not been hydrated yet."]}),"\n",(0,t.jsxs)(n.p,{children:["If your app does depends on the persisted state at page load,\r\nsee ",(0,t.jsx)(n.a,{href:"#how-can-i-check-if-my-store-has-been-hydrated",children:(0,t.jsx)(n.em,{children:"How can I check if my store has been hydrated"})}),"\r\nin the ",(0,t.jsx)(n.a,{href:"#faq",children:"FAQ"})," section below."]}),"\n",(0,t.jsx)(n.h3,{id:"usage-in-nextjs",children:"Usage in Next.js"}),"\n",(0,t.jsx)(n.p,{children:"NextJS uses Server Side Rendering, and it will compare the rendered component on the server with the one rendered on client.\r\nBut since you are using data from browser to change your component, the two renders will differ and Next will throw a warning at you."}),"\n",(0,t.jsx)(n.p,{children:"The errors usually are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Text content does not match server-rendered HTML"}),"\n",(0,t.jsx)(n.li,{children:"Hydration failed because the initial UI does not match what was rendered on the server"}),"\n",(0,t.jsx)(n.li,{children:"There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"To solve these errors, create a custom hook so that Zustand waits a little before changing your components."}),"\n",(0,t.jsx)(n.p,{children:"Create a file with the following:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// useStore.ts\r\nimport { useState, useEffect } from 'react'\r\n\r\nconst useStore = <T, F>(\r\n  store: (callback: (state: T) => unknown) => unknown,\r\n  callback: (state: T) => F,\r\n) => {\r\n  const result = store(callback) as F\r\n  const [data, setData] = useState<F>()\r\n\r\n  useEffect(() => {\r\n    setData(result)\r\n  }, [result])\r\n\r\n  return data\r\n}\r\n\r\nexport default useStore\n"})}),"\n",(0,t.jsx)(n.p,{children:"Now in your pages, you will use the hook a little bit differently:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// useBearStore.ts\r\n\r\nimport { create } from 'zustand'\r\nimport { persist } from 'zustand/middleware'\r\n\r\n// the store itself does not need any change\r\nexport const useBearStore = create(\r\n  persist(\r\n    (set, get) => ({\r\n      bears: 0,\r\n      addABear: () => set({ bears: get().bears + 1 }),\r\n    }),\r\n    {\r\n      name: 'food-storage',\r\n    },\r\n  ),\r\n)\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// yourComponent.tsx\r\n\r\nimport useStore from './useStore'\r\nimport { useBearStore } from './stores/useBearStore'\r\n\r\nconst bears = useStore(useBearStore, (state) => state.bears)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Credits: ",(0,t.jsx)(n.a,{href:"https://github.com/pmndrs/zustand/issues/938#issuecomment-1481801942",children:"This reply to an issue"}),", which points to ",(0,t.jsx)(n.a,{href:"https://dev.to/abdulsamad/how-to-use-zustands-persist-middleware-in-nextjs-4lb5",children:"this blog post"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"faq",children:"FAQ"}),"\n",(0,t.jsx)(n.h3,{id:"how-can-i-check-if-my-store-has-been-hydrated",children:"How can I check if my store has been hydrated"}),"\n",(0,t.jsx)(n.p,{children:"There are a few different ways to do this."}),"\n",(0,t.jsxs)(n.p,{children:["You can use the ",(0,t.jsx)(n.a,{href:"#onrehydratestorage",children:(0,t.jsx)(n.code,{children:"onRehydrateStorage"})}),"\r\nlistener function to update a field in the store:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const useBoundStore = create(\r\n  persist(\r\n    (set, get) => ({\r\n      // ...\r\n      _hasHydrated: false,\r\n      setHasHydrated: (state) => {\r\n        set({\r\n          _hasHydrated: state\r\n        });\r\n      }\r\n    }),\r\n    {\r\n      // ...\r\n      onRehydrateStorage: () => (state) => {\r\n        state.setHasHydrated(true)\r\n      }\r\n    }\r\n  )\r\n);\r\n\r\nexport default function App() {\r\n  const hasHydrated = useBoundStore(state => state._hasHydrated);\r\n\r\n  if (!hasHydrated) {\r\n    return <p>Loading...</p>\r\n  }\r\n\r\n  return (\r\n    // ...\r\n  );\r\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["You can also create a custom ",(0,t.jsx)(n.code,{children:"useHydration"})," hook:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const useBoundStore = create(persist(...))\r\n\r\nconst useHydration = () => {\r\n  const [hydrated, setHydrated] = useState(false)\r\n\r\n  useEffect(() => {\r\n    // Note: This is just in case you want to take into account manual rehydration.\r\n    // You can remove the following line if you don't need it.\r\n    const unsubHydrate = useBoundStore.persist.onHydrate(() => setHydrated(false))\r\n\r\n    const unsubFinishHydration = useBoundStore.persist.onFinishHydration(() => setHydrated(true))\r\n\r\n    setHydrated(useBoundStore.persist.hasHydrated())\r\n\r\n    return () => {\r\n      unsubHydrate()\r\n      unsubFinishHydration()\r\n    }\r\n  }, [])\r\n\r\n  return hydrated\r\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"how-can-i-use-a-custom-storage-engine",children:"How can I use a custom storage engine"}),"\n",(0,t.jsx)(n.p,{children:"If the storage you want to use does not match the expected API, you can create your own storage:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { create } from 'zustand'\r\nimport { persist, createJSONStorage, StateStorage } from 'zustand/middleware'\r\nimport { get, set, del } from 'idb-keyval' // can use anything: IndexedDB, Ionic Storage, etc.\r\n\r\n// Custom storage object\r\nconst storage: StateStorage = {\r\n  getItem: async (name: string): Promise<string | null> => {\r\n    console.log(name, 'has been retrieved')\r\n    return (await get(name)) || null\r\n  },\r\n  setItem: async (name: string, value: string): Promise<void> => {\r\n    console.log(name, 'with value', value, 'has been saved')\r\n    await set(name, value)\r\n  },\r\n  removeItem: async (name: string): Promise<void> => {\r\n    console.log(name, 'has been deleted')\r\n    await del(name)\r\n  },\r\n}\r\n\r\nexport const useBoundStore = create(\r\n  persist(\r\n    (set, get) => ({\r\n      bears: 0,\r\n      addABear: () => set({ bears: get().bears + 1 }),\r\n    }),\r\n    {\r\n      name: 'food-storage', // unique name\r\n      storage: createJSONStorage(() => storage),\r\n    },\r\n  ),\r\n)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If you're using a type that ",(0,t.jsx)(n.code,{children:"JSON.stringify()"})," doesn't support, you'll need to write your own serialization/deserialization code. However, if this is tedious, you can use third-party libraries to serialize and deserialize different types of data."]}),"\n",(0,t.jsxs)(n.p,{children:["For example, ",(0,t.jsx)(n.a,{href:"https://github.com/blitz-js/superjson",children:"Superjson"})," can serialize data along with its type, allowing the data to be parsed back to its original type upon deserialization"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import superjson from 'superjson' //  can use anything: serialize-javascript, devalue, etc.\r\nimport { PersistStorage } from 'zustand/middleware'\r\n\r\ninterface BearState {\r\n  bear: Map<string, string>\r\n  fish: Set<string>\r\n  time: Date\r\n  query: RegExp\r\n}\r\n\r\nconst storage: PersistStorage<BearState> = {\r\n  getItem: (name) => {\r\n    const str = localStorage.getItem(name)\r\n    if (!str) return null\r\n    return superjson.parse(str)\r\n  },\r\n  setItem: (name, value) => {\r\n    localStorage.setItem(name, superjson.stringify(value))\r\n  },\r\n  removeItem: (name) => localStorage.removeItem(name),\r\n}\r\n\r\nconst initialState: BearState = {\r\n  bear: new Map(),\r\n  fish: new Set(),\r\n  time: new Date(),\r\n  query: new RegExp(''),\r\n}\r\n\r\nexport const useBearStore = create<BearState>()(\r\n  persist(\r\n    (set) => ({\r\n      ...initialState,\r\n      // ...\r\n    }),\r\n    {\r\n      name: 'food-storage',\r\n      storage,\r\n    },\r\n  ),\r\n)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"how-can-i-rehydrate-on-storage-event",children:"How can I rehydrate on storage event"}),"\n",(0,t.jsx)(n.p,{children:"You can use the Persist API to create your own implementation,\r\nsimilar to the example below:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"type StoreWithPersist = Mutate<StoreApi<State>, [[\"zustand/persist\", unknown]]>\r\n\r\nexport const withStorageDOMEvents = (store: StoreWithPersist) => {\r\n  const storageEventCallback = (e: StorageEvent) => {\r\n    if (e.key === store.persist.getOptions().name && e.newValue) {\r\n      store.persist.rehydrate()\r\n    }\r\n  }\r\n\r\n  window.addEventListener('storage', storageEventCallback)\r\n\r\n  return () => {\r\n    window.removeEventListener('storage', storageEventCallback)\r\n  }\r\n}\r\n\r\nconst useBoundStore = create(persist(...))\r\nwithStorageDOMEvents(useBoundStore)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"how-do-i-use-it-with-typescript",children:"How do I use it with TypeScript"}),"\n",(0,t.jsxs)(n.p,{children:["Basic typescript usage doesn't require anything special\r\nexcept for writing ",(0,t.jsx)(n.code,{children:"create<State>()(...)"})," instead of ",(0,t.jsx)(n.code,{children:"create(...)"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { create } from 'zustand'\r\nimport { persist, createJSONStorage } from 'zustand/middleware'\r\n\r\ninterface MyState {\r\n  bears: number\r\n  addABear: () => void\r\n}\r\n\r\nexport const useBearStore = create<MyState>()(\r\n  persist(\r\n    (set, get) => ({\r\n      bears: 0,\r\n      addABear: () => set({ bears: get().bears + 1 }),\r\n    }),\r\n    {\r\n      name: 'food-storage', // name of item in the storage (must be unique)\r\n      storage: createJSONStorage(() => sessionStorage), // (optional) by default the 'localStorage' is used\r\n      partialize: (state) => ({ bears: state.bears }),\r\n    },\r\n  ),\r\n)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"how-do-i-use-it-with-map-and-set",children:"How do I use it with Map and Set"}),"\n",(0,t.jsxs)(n.p,{children:["In order to persist object types such as ",(0,t.jsx)(n.code,{children:"Map"})," and ",(0,t.jsx)(n.code,{children:"Set"}),", they will need to be converted to JSON-serializable types such as an ",(0,t.jsx)(n.code,{children:"Array"})," which can be done by defining a custom ",(0,t.jsx)(n.code,{children:"storage"})," engine."]}),"\n",(0,t.jsxs)(n.p,{children:["Let's say your state uses ",(0,t.jsx)(n.code,{children:"Map"})," to handle a list of ",(0,t.jsx)(n.code,{children:"transactions"}),",\r\nthen you can convert the ",(0,t.jsx)(n.code,{children:"Map"})," into an ",(0,t.jsx)(n.code,{children:"Array"})," in the ",(0,t.jsx)(n.code,{children:"storage"})," prop which is shown below:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"\r\ninterface BearState {\r\n  .\r\n  .\r\n  .\r\n  transactions: Map<any>\r\n}\r\n\r\n  storage: {\r\n    getItem: (name) => {\r\n      const str = localStorage.getItem(name);\r\n      if (!str) return null;\r\n      const { state } = JSON.parse(str);\r\n      return {\r\n        state: {\r\n          ...state,\r\n          transactions: new Map(state.transactions),\r\n        },\r\n      }\r\n    },\r\n    setItem: (name, newValue: StorageValue<BearState>) => {\r\n      // functions cannot be JSON encoded\r\n      const str = JSON.stringify({\r\n        state: {\r\n          ...newValue.state,\r\n          transactions: Array.from(newValue.state.transactions.entries()),\r\n        },\r\n      })\r\n      localStorage.setItem(name, str)\r\n    },\r\n    removeItem: (name) => localStorage.removeItem(name),\r\n  },\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>i});var t=r(6540);const s={},a=t.createContext(s);function o(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);