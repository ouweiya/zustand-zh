"use strict";(self.webpackChunkzustand_zh=self.webpackChunkzustand_zh||[]).push([[435],{134:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var s=n(4848),a=n(8453);const r={title:"Updating state",nav:3},i=void 0,o={id:"guides/updating-state",title:"Updating state",description:"Flat updates",source:"@site/docs/guides/updating-state.md",sourceDirName:"guides",slug:"/guides/updating-state",permalink:"/zustand-zh/docs/guides/updating-state",draft:!1,unlisted:!1,editUrl:"https://github.com/ouweiya/zustand-zh/blob/master/docs/guides/updating-state.md",tags:[],version:"current",frontMatter:{title:"Updating state",nav:3},sidebar:"tutorialSidebar",previous:{title:"Comparison",permalink:"/zustand-zh/docs/getting-started/comparison"},next:{title:"Immutable state and merging",permalink:"/zustand-zh/docs/guides/immutable-state-and-merging"}},d={},c=[{value:"Flat updates",id:"flat-updates",level:2},{value:"Deeply nested object",id:"deeply-nested-object",level:2},{value:"Normal approach",id:"normal-approach",level:3},{value:"With Immer",id:"with-immer",level:3},{value:"With optics-ts",id:"with-optics-ts",level:3},{value:"With Ramda",id:"with-ramda",level:3},{value:"CodeSandbox Demo",id:"codesandbox-demo",level:3}];function l(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"flat-updates",children:"Flat updates"}),"\n",(0,s.jsxs)(t.p,{children:["Updating state with Zustand is simple! Call the provided ",(0,s.jsx)(t.code,{children:"set"})," function with\r\nthe new state, and it will be shallowly merged with the existing state in the\r\nstore. ",(0,s.jsx)(t.strong,{children:"Note"})," See next section for nested state."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"import { create } from 'zustand'\r\n\r\ntype State = {\r\n  firstName: string\r\n  lastName: string\r\n}\r\n\r\ntype Action = {\r\n  updateFirstName: (firstName: State['firstName']) => void\r\n  updateLastName: (lastName: State['lastName']) => void\r\n}\r\n\r\n// Create your store, which includes both state and (optionally) actions\r\nconst usePersonStore = create<State & Action>((set) => ({\r\n  firstName: '',\r\n  lastName: '',\r\n  updateFirstName: (firstName) => set(() => ({ firstName: firstName })),\r\n  updateLastName: (lastName) => set(() => ({ lastName: lastName })),\r\n}))\r\n\r\n// In consuming app\r\nfunction App() {\r\n  // \"select\" the needed state and actions, in this case, the firstName value\r\n  // and the action updateFirstName\r\n  const firstName = usePersonStore((state) => state.firstName)\r\n  const updateFirstName = usePersonStore((state) => state.updateFirstName)\r\n\r\n  return (\r\n    <main>\r\n      <label>\r\n        First name\r\n        <input\r\n          // Update the \"firstName\" state\r\n          onChange={(e) => updateFirstName(e.currentTarget.value)}\r\n          value={firstName}\r\n        />\r\n      </label>\r\n\r\n      <p>\r\n        Hello, <strong>{firstName}!</strong>\r\n      </p>\r\n    </main>\r\n  )\r\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"deeply-nested-object",children:"Deeply nested object"}),"\n",(0,s.jsx)(t.p,{children:"If you have a deep state object like this:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"type State = {\r\n  deep: {\r\n    nested: {\r\n      obj: { count: number }\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"Updating nested state requires some effort to ensure the process is completed\r\nimmutably."}),"\n",(0,s.jsx)(t.h3,{id:"normal-approach",children:"Normal approach"}),"\n",(0,s.jsxs)(t.p,{children:["Similar to React or Redux, the normal approach is to copy each level of the\r\nstate object. This is done with the spread operator ",(0,s.jsx)(t.code,{children:"..."}),", and by manually\r\nmerging that in with the new state values. Like so:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"  normalInc: () =>\r\n    set((state) => ({\r\n      deep: {\r\n        ...state.deep,\r\n        nested: {\r\n          ...state.deep.nested,\r\n          obj: {\r\n            ...state.deep.nested.obj,\r\n            count: state.deep.nested.obj.count + 1\r\n          }\r\n        }\r\n      }\r\n    })),\n"})}),"\n",(0,s.jsx)(t.p,{children:"This is very long! Let's explore some alternatives that will make your life\r\neasier."}),"\n",(0,s.jsx)(t.h3,{id:"with-immer",children:"With Immer"}),"\n",(0,s.jsxs)(t.p,{children:["Many people use ",(0,s.jsx)(t.a,{href:"https://github.com/immerjs/immer",children:"Immer"})," to update nested\r\nvalues. Immer can be used anytime you need to update nested state such as in\r\nReact, Redux and of course, Zustand!"]}),"\n",(0,s.jsx)(t.p,{children:"You can use Immer to shorten your state updates for deeply nested object. Let's\r\ntake a look at an example:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"  immerInc: () =>\r\n    set(produce((state: State) => { ++state.deep.nested.obj.count })),\n"})}),"\n",(0,s.jsxs)(t.p,{children:["What a reduction! Please take note of the ",(0,s.jsx)(t.a,{href:"/zustand-zh/docs/integrations/immer-middleware",children:"gotchas listed here"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"with-optics-ts",children:"With optics-ts"}),"\n",(0,s.jsxs)(t.p,{children:["There is another option with ",(0,s.jsx)(t.a,{href:"https://github.com/akheron/optics-ts/",children:"optics-ts"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:'  opticsInc: () =>\r\n    set(O.modify(O.optic<State>().path("deep.nested.obj.count"))((c) => c + 1)),\n'})}),"\n",(0,s.jsx)(t.p,{children:"Unlike Immer, optics-ts doesn't use proxies or mutation syntax."}),"\n",(0,s.jsx)(t.h3,{id:"with-ramda",children:"With Ramda"}),"\n",(0,s.jsxs)(t.p,{children:["You can also use ",(0,s.jsx)(t.a,{href:"https://ramdajs.com/",children:"Ramda"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:'  ramdaInc: () =>\r\n    set(R.modifyPath(["deep", "nested", "obj", "count"], (c) => c + 1)),\n'})}),"\n",(0,s.jsx)(t.p,{children:"Both ramda and optics-ts also work with types."}),"\n",(0,s.jsx)(t.h3,{id:"codesandbox-demo",children:"CodeSandbox Demo"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://codesandbox.io/s/zustand-normal-immer-optics-ramda-updating-ynn3o?file=/src/App.tsx",children:"https://codesandbox.io/s/zustand-normal-immer-optics-ramda-updating-ynn3o?file=/src/App.tsx"})})]})}function p(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var s=n(6540);const a={},r=s.createContext(a);function i(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);